# Cpp Module 09

## ex00

```
특정 날짜에 특정 금액의 비트코인 가치를 출력하는 프로그램을 만들어야 합니다.

이 프로그램은 시간 경과에 따른 비트코인 가격을 나타낼 수 있는 데이터베이스를 사용해야 합니다. 이 데이터베이스는 이 주제와 함께 제공됩니다.
프로그램은 평가할 다른 가격/날짜를 저장하는 두 번째 데이터베이스를 입력으로 받습니다.

프로그램은 이 규칙을 준수해야 합니다:
- 프로그램 이름은 btc입니다.
- 프로그램은 파일을 인수로 받아야 합니다.
- 이 파일의 각 줄은 다음 형식을 사용해야 합니다: "날짜 | 값".
- 유효한 날짜는 항상 다음 형식입니다: 연-월-일.
- 유효한 값은 0에서 1000 사이의 부동 소수점 또는 양의 정수여야 합니다.

이 연습의 유효성을 검사하려면 코드에서 하나 이상의 컨테이너를 사용해야 합니다. 발생 가능한 오류는 적절한 오류 메시지로 처리해야 합니다.

프로그램은 입력 파일에 있는 값을 사용합니다.
프로그램은 데이터베이스에 표시된 날짜에 따라 값에 환율을 곱한 결과를 표준 출력에 표시해야 합니다.
입력에 사용된 날짜가 DB에 존재하지 않는 경우 DB에 포함된 가장 가까운 날짜를 사용해야 합니다. 상위 날짜가 아닌 하위 날짜를 사용하도록 주의하세요.

경고: 이 연습의 유효성을 검사하는 데 사용하는 컨테이너는 더 이상 이 모듈의 나머지 부분에서는 더 이상 사용할 수 없습니다.
```

## ex01

```
이러한 제약 조건이 있는 프로그램을 생성해야 합니다:

- 프로그램 이름은 RPN입니다.
- 프로그램은 반전된 폴란드 수학 식을 인수로 받아야 합니다.
- 이 연산에 사용되며 인수로 전달되는 숫자는 항상 10보다 작아야 합니다.
보다 작아야 합니다. 계산 자체뿐만 아니라 결과도 이 규칙을 고려하지 않습니다.
- 프로그램은 이 표현식을 처리하고 올바른 결과를 표준 출력에 출력해야 합니다.
표준 출력에 올바른 결과를 출력해야 합니다.
- 프로그램을 실행하는 동안 오류가 발생하면 오류 메시지가
가 표준 출력에 표시되어야 합니다.
- 프로그램은 이러한 토큰을 사용한 연산을 처리할 수 있어야 합니다: "+ - / *".

이 연습의 유효성을 검사하려면 코드에서 컨테이너를 하나 이상 사용해야 합니다. 연습을 해야 합니다.

대괄호나 소수는 관리할 필요가 없습니다.

경고: 이전 연습에서 사용한 컨테이너는 여기서는 금지되어 있습니다. 이 연습의 유효성을 검사하는 데 사용한 컨테이너는 이 모듈의 나머지 부분에서는 사용할 수 없습니다.
```

## ex02

```
이러한 제약 조건이 있는 프로그램을 생성해야 합니다:

- 프로그램 이름은 PmergeMe입니다.
- 프로그램은 양의 정수 수열을 인수로 사용할 수 있어야 합니다.
- 프로그램은 병합-삽입 정렬 알고리즘을 사용하여 양의 정수 시퀀스를 정렬해야 합니다. 명확히 말하면, 예, 포드-존슨 알고리즘을 사용해야 합니다.
- 프로그램 실행 중에 오류가 발생하면 표준 출력에 오류 메시지가 표시되어야 합니다.

이 연습의 유효성을 검사하려면 코드에 적어도 두 개의 서로 다른 컨테이너를 사용해야 합니다. 프로그램은 최소 3000개의 서로 다른 정수를 처리할 수 있어야 합니다.

각 컨테이너에 대해 알고리즘을 구현할 것을 강력히 권장합니다. 따라서 일반 함수를 사용하지 않는 것이 좋습니다.
다음은 한 줄씩 표시해야 하는 정보에 대한 몇 가지 추가 지침입니다. 표시해야 하는 정보에 대한 추가 지침은 다음과 같습니다:
- 첫 번째 줄에는 명시적인 텍스트와 정렬되지 않은 양의 정수 시퀀스를 표시해야 합니다.
- 두 번째 줄에는 명시적 텍스트와 정렬된 양의 정수 시퀀스를 표시해야 합니다.
- 세 번째 줄에는 양의 정수 수열을 정렬하는 데 사용된 첫 번째 컨테이너를 지정하여 알고리즘에서 사용한 시간을 나타내는 명시적 텍스트를 표시해야 합니다.
- 마지막 줄에는 양의 정수 수열을 정렬하는 데 사용되는 두 번째 컨테이너를 지정하여 알고리즘에서 사용한 시간을 나타내는 명시적인 텍스트를 표시해야 합니다.

분류를 수행하는 데 사용된 시간을 표시하는 형식은 자유지만, 사용된 두 컨테이너의 차이를 명확하게 볼 수 있는 정밀도를 선택해야 합니다.

이 예제에서는 시간 표시가 일부러 이상하게 되어 있습니다.
물론 정렬 부분과 데이터 관리 부분 모두 모든 작업을 수행하는 데 사용된 시간을 표시해야 합니다.

경고: 이전 연습에서 사용한 컨테이너는 여기서는 사용할 수 없습니다. 

중복과 관련된 오류 관리는 여러분의 재량에 맡기세요. 재량에 맡겨집니다.
```

### Ford-Johnson Algorithm

1959년에 발견되어 1979년까지 비교가 가장 적은 정렬 알고리즘으로 알려진 알고리즘.

`가장 최적의 알고리즘은 무엇일까?` 라는 고민에서 출발하여 `비교가 가장 적은 정렬 알고리즘이 가장 최적의 알고리즘일 것이다.` 라는 가정에서 출발한 알고리즘.

기수 정렬과 같이 비교를 하지 않는 알고리즘이 있기에 가정이 맞지 않을 수 있지만, `하나의 추만 허용하는 저울의 팬이 있을 때 저울을 사용하여 추들의 무게를 정렬하는 문제` 또는 `토너먼트에 참가하는 N명의 플레이어가 주어졌을 때, 플레이어의 순위가 동점 없이 선형적으로 정렬될 수 있다고 가정하고 모든 참가자의 순위를 매기는 데 충분한 최소 게임 수를 찾는 문제` 등의 문제를 해결할 때 사용할 수 있다.


### References

- [Merge-insertion Sort](https://en.wikipedia.org/wiki/Merge-insertion_sort)
- [merge-insertion sort, 혹은 Ford–Johnson algorithm 찬찬히 뜯어보기](https://ebang.tistory.com/103)
- [MergeInsertionSort (Ford-Johnson Algorithm) 를 구현하기 전에](https://tolerblanc.github.io/algorithm/merge-insertion-sort/)
- [cpp09 - mergeInsertionSort(ford-johnson algorithm)](https://80000coding.oopy.io/6880ebc0-acb3-4225-809f-37fc419adf71)
- [CPP Module 09 self check list](https://hijkl2e.tistory.com/147)
- [Merge-insertion Sort](https://iq.opengenus.org/merge-insertion-sort/)
- [Ford-Johnson Merge-Insertion Sort](https://codereview.stackexchange.com/questions/116367/ford-johnson-merge-insertion-sort)
